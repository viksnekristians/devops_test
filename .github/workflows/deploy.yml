name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      tag:
        description: 'Image tag to deploy (e.g., v1.0.0, main, sha-abc123)'
        required: true
        type: string
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'push')
    permissions:
      contents: read
      packages: read

    steps:
    - uses: actions/checkout@v3

    - name: Set deployment tag
      id: set-tag
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "tag=${{ github.event.inputs.tag }}" >> $GITHUB_OUTPUT
        else
          echo "tag=sha-${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
        fi

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Check image exists
      run: |
        docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.tag }}

    - name: Deploy to server via SSH
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.DEPLOY_HOST }}
        username: ${{ secrets.DEPLOY_USER }}
        key: ${{ secrets.DEPLOY_KEY }}
        port: ${{ secrets.DEPLOY_PORT }}
        script: |
          # Ensure docker-compose is installed
          if ! command -v docker-compose &> /dev/null; then
            echo "Installing docker-compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi

          # Create production directory
          mkdir -p ~/production
          cd ~/production

          # Download production compose file from repository
          curl -sL https://raw.githubusercontent.com/${{ github.repository }}/main/docker-compose.prod.yml -o docker-compose.yml

          # Create .env file with production variables
          cat > .env <<EOF
          IMAGE_TAG=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.set-tag.outputs.tag }}
          DB_NAME=${{ secrets.PROD_DB_NAME || 'production_db' }}
          DB_USER=${{ secrets.PROD_DB_USER || 'prod_user' }}
          DB_PASSWORD=${{ secrets.PROD_DB_PASSWORD }}
          MYSQL_ROOT_PASSWORD=${{ secrets.PROD_MYSQL_ROOT_PASSWORD }}
          EOF

          # Stop and start services with new image
          docker-compose pull app
          docker-compose up -d

          # Wait for health check
          echo "⏳ Waiting for services to be healthy..."
          for i in {1..30}; do
            if docker-compose ps | grep -q "healthy"; then
              echo "✅ Production deployment successful!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "❌ Services failed to become healthy"
              docker-compose logs app
              exit 1
            fi
            sleep 2
          done

          # Clean up old images
          docker system prune -af --filter "until=24h"