name: Deploy to Staging

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: true
        type: string
        default: 'develop'
  push:
    branches:
      - develop
      - 'feature/**'
      - 'hotfix/**'
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
      - develop

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  check-duplicate:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
    steps:
      - name: Check if should run
        id: check
        run: |
          # For PRs, always run
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "âœ… Running for PR event"
          # For pushes, check if it's to a PR branch
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            # Get branch name
            BRANCH="${GITHUB_REF#refs/heads/}"
            # Check if there's an open PR for this branch
            PR_COUNT=$(curl -s -H "Authorization: token ${{ github.token }}" \
              "https://api.github.com/repos/${{ github.repository }}/pulls?state=open&head=${{ github.repository_owner }}:${BRANCH}" \
              | jq '. | length')

            if [[ "${PR_COUNT}" -gt 0 ]]; then
              echo "should_run=false" >> $GITHUB_OUTPUT
              echo "â­ï¸ Skipping push event - PR workflow will handle it"
            else
              echo "should_run=true" >> $GITHUB_OUTPUT
              echo "âœ… Running for push event (no PR exists)"
            fi
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "âœ… Running for manual trigger"
          fi

  assign-port:
    runs-on: ubuntu-latest
    needs: check-duplicate
    if: needs.check-duplicate.outputs.should_run == 'true'
    outputs:
      port: ${{ steps.assign.outputs.port }}
      branch_name: ${{ steps.assign.outputs.branch_name }}
      container_name: ${{ steps.assign.outputs.container_name }}
    steps:
      - name: Determine branch name
        id: branch
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BRANCH="${{ github.head_ref }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            BRANCH="${{ github.event.inputs.branch }}"
          else
            BRANCH="${GITHUB_REF#refs/heads/}"
          fi
          echo "name=${BRANCH}" >> $GITHUB_OUTPUT

      - name: Assign port based on branch
        id: assign
        run: |
          BRANCH="${{ steps.branch.outputs.name }}"
          echo "branch_name=${BRANCH}" >> $GITHUB_OUTPUT

          # Fixed ports for main branches
          if [[ "${BRANCH}" == "develop" ]]; then
            PORT=9000
            CONTAINER_NAME="staging-main"
          elif [[ "${BRANCH}" == "main" ]]; then
            # Skip staging for main branch (it goes to production)
            echo "skip=true" >> $GITHUB_OUTPUT
            exit 0
          else
            # Generate consistent port for feature branches (9001-9099)
            # Use hash of branch name for consistent port assignment
            HASH=$(echo -n "${BRANCH}" | md5sum | cut -c1-8)
            PORT_OFFSET=$((0x${HASH} % 99))
            PORT=$((9001 + ${PORT_OFFSET}))

            # Sanitize branch name for container name
            SAFE_BRANCH=$(echo "${BRANCH}" | sed 's/[^a-zA-Z0-9-]/-/g' | tr '[:upper:]' '[:lower:]')
            CONTAINER_NAME="staging-${SAFE_BRANCH}"
          fi

          echo "port=${PORT}" >> $GITHUB_OUTPUT
          echo "container_name=${CONTAINER_NAME}" >> $GITHUB_OUTPUT

          echo "ğŸ“Œ Branch: ${BRANCH}"
          echo "ğŸ“Œ Port: ${PORT}"
          echo "ğŸ“Œ Container: ${CONTAINER_NAME}"

  build-and-push:
    runs-on: ubuntu-latest
    needs: assign-port
    if: needs.assign-port.outputs.skip != 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
    steps:
      - uses: actions/checkout@v3
        with:
          ref: ${{ needs.assign-port.outputs.branch_name }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare safe tag
        id: safe-tag
        run: |
          BRANCH="${{ needs.assign-port.outputs.branch_name }}"
          SAFE_TAG=$(echo "staging-${BRANCH}" | sed 's/\//-/g')
          echo "tag=${SAFE_TAG}" >> $GITHUB_OUTPUT

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.safe-tag.outputs.tag }}
            type=sha,format=long,prefix=staging-

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            APP_ENV=staging
            APP_DEBUG=true

  deploy:
    runs-on: ubuntu-latest
    needs: [assign-port, build-and-push]
    if: needs.assign-port.outputs.skip != 'true'
    environment:
      name: staging-${{ needs.assign-port.outputs.branch_name }}
    permissions:
      contents: read
      packages: read
      pull-requests: write
    steps:
      - name: Deploy to staging server
        id: deploy
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.STAGING_HOST || secrets.DEPLOY_HOST }}
          username: ${{ secrets.STAGING_USER || secrets.DEPLOY_USER }}
          key: ${{ secrets.STAGING_KEY || secrets.DEPLOY_KEY }}
          port: ${{ secrets.STAGING_PORT || secrets.DEPLOY_PORT || '22' }}
          script: |
            set -e

            CONTAINER_NAME="${{ needs.assign-port.outputs.container_name }}"
            PORT="${{ needs.assign-port.outputs.port }}"
            BRANCH_NAME="${{ needs.assign-port.outputs.branch_name }}"
            # Sanitize branch name for Docker tag (replace / with -)
            SAFE_TAG=$(echo "staging-${BRANCH_NAME}" | sed 's/\//-/g')

            echo "ğŸš€ Deploying ${CONTAINER_NAME} on port ${PORT}"
            echo "ğŸ“¦ Using image tag: ${SAFE_TAG}"

            # Pull the new image
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${SAFE_TAG}

            # Stop and remove existing container if it exists
            if docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
              echo "â¹ï¸  Stopping existing container..."
              docker stop ${CONTAINER_NAME} || true
              # Wait a bit for container to stop
              sleep 2
              docker rm -f ${CONTAINER_NAME} || true
              # Extra wait to ensure cleanup
              sleep 1
            fi

            # Create a file to track port assignments (in user's home directory)
            mkdir -p ~/staging-ports
            echo "${{ needs.assign-port.outputs.branch_name }}" > ~/staging-ports/port-${PORT}.txt

            # Ensure docker-compose is installed
            if ! command -v docker-compose &> /dev/null; then
              echo "Installing docker-compose..."
              sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi

            # Create staging directory if not exists
            mkdir -p ~/staging-deployments/${CONTAINER_NAME}
            cd ~/staging-deployments/${CONTAINER_NAME}

            # Download compose template from repository
            curl -sL https://raw.githubusercontent.com/${{ github.repository }}/${{ needs.assign-port.outputs.branch_name }}/docker-compose.staging.yml -o docker-compose.yml

            # Generate secure database password for this instance
            DB_PASSWORD="staging_$(openssl rand -hex 16)_${PORT}"

            # Create .env file with deployment-specific variables
            cat > .env <<EOF
            IMAGE_TAG=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${SAFE_TAG}
            CONTAINER_NAME=${CONTAINER_NAME}
            PORT=${PORT}
            BRANCH_NAME=${{ needs.assign-port.outputs.branch_name }}
            DB_PASSWORD=${DB_PASSWORD}
            DEPLOYED_AT=$(date -Iseconds)
            EOF

            # Stop and remove existing containers if they exist
            docker-compose down --volumes 2>/dev/null || true

            # Pull the latest images
            docker-compose pull

            # Start the services
            docker-compose up -d

            # Wait for services to be healthy
            echo "â³ Waiting for services to be healthy..."
            for i in {1..30}; do
              if docker-compose ps | grep -q "healthy"; then
                echo "âœ… Services are healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ Services failed to become healthy"
                docker-compose logs
                exit 1
              fi
              sleep 2
            done

            # Clean up old images (ignore errors if another cleanup is running)
            docker image prune -af --filter "until=24h" || true

            echo "âœ… Deployment successful!"
            echo "ğŸŒ URL: http://${{ secrets.DEPLOY_HOST }}:${PORT}"

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const port = '${{ needs.assign-port.outputs.port }}';
            const host = '${{ secrets.DEPLOY_HOST }}';
            const branch = '${{ needs.assign-port.outputs.branch_name }}';
            const url = `http://${host}:${port}`;

            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('ğŸš€ Staging Environment')
            );

            const body = `ğŸš€ **Staging Environment Deployed!**

            **Branch:** \`${branch}\`
            **URL:** ${url}
            **Port:** ${port}
            **Container:** \`${{ needs.assign-port.outputs.container_name }}\`

            This staging environment will be automatically updated with each push to this PR.

            ---
            *Last deployed: ${new Date().toISOString()}*`;

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Output deployment info
        run: |
          echo "âœ… Staging Deployed Successfully!"
          echo "ğŸ“ URL: http://${{ secrets.DEPLOY_HOST }}:${{ needs.assign-port.outputs.port }}"
          echo "ğŸ·ï¸ Branch: ${{ needs.assign-port.outputs.branch_name }}"
          echo "ğŸ“¦ Container: ${{ needs.assign-port.outputs.container_name }}"
          echo "ğŸ”Œ Port: ${{ needs.assign-port.outputs.port }}"